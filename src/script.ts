import { Script } from '@script_types/script/script';
import { DataSourcesTypes as DS } from '@script_types/sources/sources_types';
import { ScriptConfig } from '../gen/spec_config'; /* File will be automatically generated by compiler! Run "nom run cli install" */
import { specification } from './spec';
import { AssistantMessages } from './socket_messages';
import { AsssistantCommand } from './socket_command';
import { SourceLights } from './sources/lights';
import { SourceDeviceLights } from '@script_types/sources/devices/source_device_lights';
import { SourceCovers } from './sources/covers';
import { SourceDeviceCovers } from '@script_types/sources/devices/source_device_covers';
import { ParameterType } from '@script_types/spec/spec_parameter';

type ProvidedSources = "compute" | "device_lights" | "device_covers";

export let sendToDisplay: FnSendToDisplay | undefined;
export type FnSendToDisplay = (ident: ProvidedSources, data: object) => void;

export interface SocketInfo {
    uid: string;
}

export let verbose = false;

export let renamings: {
    device_id?: { value: string ,  name: string };
    name?: { value: string ,  name: string };
}[] = [];

export class MyScript implements Script.Class<ScriptConfig, ProvidedSources> {

    private msg_id = 1;
    private cmd_handler: AsssistantCommand;
    private msg_handler: AssistantMessages;
    
    private config: ScriptConfig | undefined;
    private ctx: Script.Context | undefined;
    private socket_info: SocketInfo | undefined;

    constructor(){
        sendToDisplay = this.sendToDisplay;
        this.cmd_handler = new AsssistantCommand({ sendMessage: this.sendMessage });
        this.msg_handler = new AssistantMessages({
            cmd_: this.cmd_handler,
            sendData: this.sendData,
            sendMessage: this.sendMessage,
            getToken: this.getToken
        });
    }

    public getToken = (): string | undefined => {
        return this.config?.token?.value;
    }

    start = async (ctx: Script.Context, config: ScriptConfig): Promise<void> => {
        this.ctx = ctx;
        this.config = config;

        console.info("Ident:" + specification.id_ident);
        console.info("Config:", config);

        if (config.device_rename) {
            renamings = config.device_rename;
        }
        if (config.verbose_log) {
            verbose = config.verbose_log.value;
        }

        let host = config.host?.value;
        const token = config.token?.value;
        if (host && token) {

            if (!host.startsWith("ws://")) {
                host = "ws://" + host;
            }
            console.debug("split test: ", host.split(":"));
            if (host.split(":").length == 2) { // there is one in ws://, check if the one for the port exists, should be 3 elements. If only 2, add the port
                host = host + ":8123";
            }
            const url = host + "/api/websocket";
            console.log(`Connect to ${url} ...`);

            const socket_info = {
                uid: "",
            }
            const result = await ctx.data.websocket.connect(url, (data) => this.msg_handler.onDataReceived(data, socket_info), {
                auto_reconnect: true,
                state_handler: (state) => {
                    console.log(`Socket '${state.uid}' state: ${state.connected ? 'connected' : 'disconnected'}`);
                    if (!state.connected) {
                        this.socket_info = undefined;
                    } else {
                        this.socket_info = {
                            uid: state.uid
                        }
                    }
                }
            });
            console.debug(`Connect result: `, result);
            if (result.uid) {
                socket_info.uid = result.uid;
                this.socket_info = socket_info;
            }
        } else {
            if (!host) console.error("Config incomplete: host not given");
            if (!token) console.error("Config incomplete: token not given");
        }

        ctx.script.registerConfigOptionsProvider(async (req) => {
            let ident = req.parameter_ident;
            console.debug("Config req: ", req);
            if (req.source == "widget") {
                if (ident == "light") {
                    // This is a request from the "light widget" selector!
                    const s_light = <SourceLights | undefined> this.msg_handler.getSourceRef("light");
                    if (s_light) {
                        return s_light.getConfigParameters();
                    } else {
                        return { no_data: 'DataMissing' };
                    }
                } else if (ident == "cover") {
                    // This is a request from the "cover widget" selector!
                    const s_cover = <SourceCovers | undefined> this.msg_handler.getSourceRef("cover");
                    if (s_cover) {
                        return s_cover.getConfigParameters();
                    } else {
                        return { no_data: 'DataMissing' };
                    }
                } else {
                    console.error("Config Options Req: UnkownID: ", ident);
                    return { no_data: 'UnknownID' };
                }
            } else if (req.source == "script_instance") {
                if (ident == "device_id") {
                    // for renaming
                    let entries: ParameterType.DropdownEntry[] = [];
                    const s_cover = <SourceCovers | undefined> this.msg_handler.getSourceRef("cover");
                    if (s_cover) {
                        const entries_t = s_cover.getConfigParameters().dropdown_entries;
                        entries_t.forEach(e => { e.name = "Cover: " + e.name });
                        entries = entries.concat(entries_t);
                    }
                    const s_light = <SourceLights | undefined> this.msg_handler.getSourceRef("light");
                    if (s_light) {
                        const entries_t = s_light.getConfigParameters().dropdown_entries;
                        entries_t.forEach(e => { e.name = "Light: " + e.name });
                        entries = entries.concat(entries_t);
                    }
                    return {
                        dropdown_entries: entries
                    }
                }
            }
        });
    }

    public sendToDisplay = (ident: ProvidedSources, data: object) => {
        this.ctx?.script.transmitData(ident, data);
    }

    private sendData = (msg: any) => {
        if (!this.socket_info) {
            console.error("sendData: no socket");
            return;
        }
        this.ctx?.data.websocket.sendData(this.socket_info.uid, msg);
    }

    private sendMessage = (msg: object): number | undefined => {
        if (!this.socket_info) {
            console.error("sendMessage: no active socket");
            return undefined;
        }
        this.msg_id ++;
        const id = this.msg_id;
        // we need to add an increasing message id - https://developers.home-assistant.io/docs/api/websocket/
        const tx_msg = Object.assign(msg, { id });
        this.ctx?.data.websocket.sendData(this.socket_info.uid, tx_msg);
        return id;
    }


    stop = async (_reason: Script.StopReason): Promise<void> => {
        console.info("Stopping all my stuff ...");
        if (this.socket_info) {
            const res = await this.ctx?.data.websocket.disconnect(this.socket_info.uid);
            console.debug(`Disconnect from '${this.config?.host?.value}' result: `, res);
        }
    }

    public dataRequest = async (type: ProvidedSources, req_params: object): Promise<DS.MapData<typeof type> | undefined> => {
        if (type == "device_lights") {
            console.log("Data Request: ", type, req_params);
            const s_light = <SourceLights | undefined> this.msg_handler.getSourceRef("light");
            if (s_light) {
                return s_light.handleDataRequestDisplay(req_params);
            } else {
                console.error("dataRequest: No 'light' servcie found")
            }
        } else if (type == "device_covers") {
            console.log("Data Request: ", type, req_params);
            const s_cover = <SourceCovers | undefined> this.msg_handler.getSourceRef("cover");
            if (s_cover) {
                return s_cover.handleDataRequestDisplay(req_params);
            } else {
                console.error("dataRequest: No 'cover' service found")
            }
        }
       return undefined;
    };

    public executeCommand = async (type: ProvidedSources, _env: Script.ExecuteEnv, _cmd: DS.MapCmdReq<typeof type>): Promise<DS.MapCmdRes<typeof type> | undefined> => {
        console.log("executeCommand: ", type, _cmd);
        if (type == "device_lights") {
            const msg = <SourceDeviceLights.Command.Request> _cmd;
            const s_light = <SourceLights | undefined> this.msg_handler.getSourceRef("light");
            if (s_light) {
                const ha_msg = await s_light.handleCommandDisplay(msg);
                if (ha_msg) {
                    this.sendMessage(ha_msg);
                    return { success: true };
                } else {
                    console.error("executeCommand: No message from 'light' service");
                }
            } else {
                console.error("executeCommand: No 'light' service found")
            }
        } else if (type == "device_covers") {
            const msg = <SourceDeviceCovers.Command.Request> _cmd;
            const s_cover = <SourceCovers | undefined> this.msg_handler.getSourceRef("cover");
            if (s_cover) {
                const ha_msg = await s_cover.handleCommandDisplay(msg);
                if (ha_msg) {
                    this.sendMessage(ha_msg);
                    return { success: true };
                }
            } else {
                console.error("executeCommand: No 'cover' service found")
            }
        } else {
            console.warn("executeCommand: No consumer implemented")
        }
        return {}
    }
}

export const script = new MyScript();